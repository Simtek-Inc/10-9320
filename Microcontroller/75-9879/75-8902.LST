C51 COMPILER V8.06   75_8902                                                               01/04/2022 08:22:26 PAGE 1   


C51 COMPILER V8.06, COMPILATION OF MODULE 75_8902
OBJECT MODULE PLACED IN 75-8902.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE 75-8902.C BROWSE DEBUG OBJECTEXTEND

line level    source

   1          //;************************************************
   2          //DESCRIPTION:
   3          //SIMTEK PART # 10-9186-01
   4          //75-8902
   5          //10/12/2021
   6          //David B.
   7          //;************************************************
   8          #include<absacc.h>
   9          #include<aduc841.h>
  10          #include<intrins.h>
  11          //;************************************************
  12          #define CONTROL_COMMAND 0x23                    //
  13          #define SWITCH_STATUS   0x24                    //
  14          #define OPTIONS                 0x25                    //
  15          #define PANEL_STATUS    0x26                    //
  16          #define ENC_POT_STATUS  0x28                    //
  17          #define ECHO_OPTION_ID  0x30                    //
  18          #define REALTIME_OPTION_ID  0x31                //
  19          #define BRT_CTRL_OPTION_ID  0x32                //
  20          //;************************************************
  21          //BEZEL PUSH BUTTON ADDRESSES
  22          //COUNT STARTS UPPER LEFT BEZEL
  23          #define PB_41 0x41                                              //
  24          #define PB_42 0x42                                              //
  25          #define PB_43 0x43                                              //
  26          #define PB_44 0x44                                              //
  27          #define PB_45 0x45                                              //
  28          #define PB_46 0x46                                              //
  29          #define PB_47 0x47                                              //
  30          #define PB_48 0x48                                              //
  31          #define PB_49 0x49                                              //
  32          #define PB_4A 0x4A                                              //
  33          #define PB_4B 0x4B                                              //
  34          #define PB_4C 0x4C                                              //
  35          #define PB_4D 0x4D                                              //
  36          #define PB_4E 0x4E                                              //
  37          #define PB_4F 0x4F                                              //
  38          #define PB_50 0x50                                              //
  39          #define PB_51 0x51                                              //
  40          #define BRT_PB 0x52                                             //
  41          #define ENC_PB 0x53                                             //
  42          #define POT_ID 0x56                                             //
  43          #define ENC_ID 0x58                                             //
  44          #define BUTTON_PRESSED 0x31                             //
  45          #define BUTTON_RELEASED 0x30                    //
  46          //;************************************************
  47          #define DISPLAY_DIM_ID 0x5A                             //
  48          #define CONTRAST_ID    0x5C                             //
  49          #define BEZEL_DIM_ID   0x5E                             //
  50          #define SKIDBALL_ID    0x60                             //
  51          //;************************************************
  52          unsigned char bdata Abyte;                                      //create a bit addressable byte
  53          sbit Abyte0 = Abyte^0;
  54          sbit Abyte1 = Abyte^1;
  55          sbit Abyte2 = Abyte^2;
C51 COMPILER V8.06   75_8902                                                               01/04/2022 08:22:26 PAGE 2   

  56          sbit Abyte3 = Abyte^3;
  57          sbit Abyte4 = Abyte^4;
  58          sbit Abyte5 = Abyte^5;
  59          sbit Abyte6 = Abyte^6;
  60          sbit Abyte7 = Abyte^7;
  61          //;************************************************
  62          unsigned char bdata Bbyte;                                      //create a bit addressable byte
  63          sbit Bbyte0 = Bbyte^0;
  64          sbit Bbyte1 = Bbyte^1;
  65          sbit Bbyte2 = Bbyte^2;
  66          sbit Bbyte3 = Bbyte^3;
  67          sbit Bbyte4 = Bbyte^4;
  68          sbit Bbyte5 = Bbyte^5;
  69          sbit Bbyte6 = Bbyte^6;
  70          sbit Bbyte7 = Bbyte^7;
  71          //;************************************************
  72          // AD7247A Control Lines                                //
  73          //;************************************************
  74          sbit csa        = P3^2;                                 //                 
  75          sbit csb        = P3^3;                                 //
  76          sbit wr         = P3^4;                                 //
  77          //;************************************************
  78          // FPGA Reset                                                   //
  79          //;************************************************
  80          sbit fpga_reset = P3^5;                                 // u3 pin 27
  81          //;************************************************
  82          // MAX144ACUA Control Lines                             //
  83          //;************************************************
  84          sbit ADC_clk    = P2^0;                                 //
  85          sbit ADC_cs     = P2^1;                                 //
  86          sbit ADC_data   = P2^3;                                 //
  87          //;************************************************
  88          // 21-500 Day/Night Control line                //
  89          //;************************************************ 
  90          sbit day_night  = P2^2;                                 // 
  91          //;************************************************
  92          bit     reset_bit                       = 0;                            // reset flag
  93          bit send_status_bit             = 0;
  94          bit update_bezel_dimming_bit    = 0;
  95          bit update_display_contrast_bit = 0;
  96          bit update_display_dimming_bit  = 0;
  97          bit update_skidball_bit         = 0;
  98          bit send_single_switch_status   = 0;
  99          bit send_encoder_status         = 0;
 100          bit send_pot_status             = 0;
 101          bit send_display_dim_values     = 0;
 102          bit send_contrast_values        = 0;
 103          bit send_bezel_dim_values       = 0;
 104          bit send_skidball_values        = 0;
 105          bit send_echo_value                     = 0;
 106          bit send_realtime_value         = 0;
 107          bit send_lcd_value                      = 0;
 108          //;************************************************
 109          unsigned char RS_micro_firmware[] =  {0x75,0x89,0x02,0x2D};
 110          unsigned char RS_fpga_firmware[4];              // array of 4 sequential storage locations 0 - 3
 111          //;************************************************
 112          unsigned char temptransmit;
 113          unsigned char tempreceive;
 114          
 115          unsigned char tempskidhi;
 116          unsigned char tempskidlo;
 117          //;************************************************
C51 COMPILER V8.06   75_8902                                                               01/04/2022 08:22:26 PAGE 3   

 118          unsigned char display_dim_msn;
 119          unsigned char display_dim_lsn;
 120          unsigned char display_dim_byte;
 121          unsigned char old_display_dim_byte;
 122          
 123          unsigned char contrast_msn = 0x30;
 124          unsigned char contrast_lsn = 0x35;
 125          unsigned char contrast_byte;
 126          
 127          unsigned char bezel_dim_msn = 0x30;
 128          unsigned char bezel_dim_lsn = 0x30;
 129          unsigned char bezel_dim_byte;
 130          
 131          unsigned char skidball_msn = 0x37;
 132          unsigned char skidball_lsn = 0x46;
 133          unsigned char skidball_byte;
 134          unsigned int  look_up_value;
 135          
 136          unsigned char enc_msn = 0x30;
 137          unsigned char enc_lsn = 0x30;
 138          unsigned char enc_byte;
 139          
 140          unsigned char brt_msn = 0x30;
 141          unsigned char brt_lsn = 0x30;
 142          unsigned char old_brt_byte; 
 143          unsigned char new_brt_byte;
 144          //;************************************************
 145          unsigned char s_display_dim_msn = 0x30;
 146          unsigned char s_display_dim_lsn = 0x30;
 147          
 148          unsigned char s_contrast_msn = 0x30;
 149          unsigned char s_contrast_lsn = 0x35;
 150          
 151          unsigned char s_bezel_dim_msn = 0x30;
 152          unsigned char s_bezel_dim_lsn = 0x30;
 153          
 154          unsigned char s_skidball_msn = 0x37;
 155          unsigned char s_skidball_lsn = 0x46;
 156          
 157          unsigned char s_enc_msn = 0x30;
 158          unsigned char s_enc_lsn = 0x30;
 159          //;************************************************
 160          unsigned char switch_id;
 161          unsigned char echo = 0x30;                                              //;ECHO OFF IS DEFAULT
 162          unsigned char realtime = 0x30;                                  //;REPORT ON CHANGE IS DEFAULT
 163          unsigned char brt_control = 0x31;                               //;SERIAL BRIGHTNESS CONTROL IS DEFAULT
 164          unsigned char Brt_Knob;
 165          //;************************************************
 166          unsigned char KEYADDRESS;
 167          unsigned char KEYDATA;
 168          unsigned char SWOLD1;
 169          unsigned char SWOLD2;
 170          unsigned char SWOLD3;
 171          unsigned char SWOLD4;
 172          unsigned char SWOLD5;
 173          //;************************************************
 174          unsigned char PB_41_Status = 0x30;                              //
 175          unsigned char PB_42_Status = 0x30;                              //
 176          unsigned char PB_43_Status = 0x30;                              //
 177          unsigned char PB_44_Status = 0x30;                              //
 178          unsigned char PB_45_Status = 0x30;                              //
 179          unsigned char PB_46_Status = 0x30;                              //
C51 COMPILER V8.06   75_8902                                                               01/04/2022 08:22:26 PAGE 4   

 180          unsigned char PB_47_Status = 0x30;                              //
 181          unsigned char PB_48_Status = 0x30;                              //
 182          unsigned char PB_49_Status = 0x30;                              //
 183          unsigned char PB_4A_Status = 0x30;                              //
 184          unsigned char PB_4B_Status = 0x30;                              //
 185          unsigned char PB_4C_Status = 0x30;                              //
 186          unsigned char PB_4D_Status = 0x30;                              //
 187          unsigned char PB_4E_Status = 0x30;                              //
 188          unsigned char PB_4F_Status = 0x30;                              //
 189          unsigned char PB_50_Status = 0x30;                              //
 190          unsigned char PB_51_Status = 0x30;                              //
 191          unsigned char BRT_PB_Status = 0x30;                             //
 192          unsigned char ENC_PB_Status = 0x30;                             //
 193          unsigned char Switch_Data;                                              //
 194          unsigned long int i;
 195          unsigned long int j;
 196          unsigned char difference;                                               //
 197          //;************************************************
 198          unsigned char code dim_value[256] =
 199          {
 200          //NVIS
 201          0xFF,0xFD,0xFB,0xF9,0xF7,0xF5,0xF3,0xF1,0xEF,0xED,0xEB,0xE9,0xE7,0xE5,0xE3,0xE1,
 202          0xDF,0xDD,0xDB,0xD9,0xD7,0xD5,0xD3,0xD1,0xCF,0xCD,0xCB,0xC9,0xC7,0xC5,0xC3,0xC1,
 203          0xBF,0xBD,0xBB,0xB9,0xB7,0xB5,0xB3,0xB1,0xAF,0xAD,0xAB,0xA9,0xA7,0xA5,0xA3,0xA1,
 204          0x9F,0x9D,0x9B,0x99,0x97,0x95,0x93,0x91,0x8F,0x8D,0x8B,0x89,0x87,0x85,0x83,0x81,
 205          0x7F,0x7D,0x7B,0x79,0x77,0x75,0x73,0x71,0x6F,0x6D,0x6B,0x69,0x67,0x65,0x63,0x61,
 206          0x5F,0x5D,0x5B,0x59,0x57,0x55,0x53,0x51,0x4F,0x4D,0x4B,0x49,0x47,0x45,0x43,0x41,
 207          0x3F,0x3D,0x3B,0x39,0x37,0x35,0x33,0x31,0x2F,0x2D,0x2B,0x29,0x27,0x25,0x23,0x21,
 208          0x1F,0x1D,0x1B,0x19,0x17,0x15,0x13,0x11,0x0F,0x0D,0x0B,0x09,0x07,0x05,0x03,0x01,
 209          //NON NVIS
 210          0xFB,0xFA,0xF9,0xF8,0xF7,0xF5,0xF3,0xF1,0xEF,0xED,0xEB,0xE9,0xE7,0xE5,0xE3,0xE1,
 211          0xDF,0xDD,0xDB,0xD9,0xD7,0xD5,0xD3,0xD1,0xCF,0xCD,0xCB,0xC9,0xC7,0xC5,0xC3,0xC1,
 212          0xBF,0xBD,0xBB,0xB9,0xB7,0xB5,0xB3,0xB1,0xAF,0xAD,0xAB,0xA9,0xA7,0xA5,0xA3,0xA1,
 213          0x9F,0x9D,0x9B,0x99,0x97,0x95,0x93,0x91,0x8F,0x8D,0x8B,0x89,0x87,0x85,0x83,0x81,
 214          0x7F,0x7D,0x7B,0x79,0x77,0x75,0x73,0x71,0x6F,0x6D,0x6B,0x69,0x67,0x65,0x63,0x61,
 215          0x5F,0x5D,0x5B,0x59,0x57,0x55,0x53,0x51,0x4F,0x4D,0x4B,0x49,0x47,0x45,0x43,0x41,
 216          0x3F,0x3D,0x3B,0x39,0x37,0x35,0x33,0x31,0x2F,0x2D,0x2B,0x29,0x27,0x25,0x23,0x21,
 217          0x1F,0x1E,0x1D,0x1C,0x1B,0x1A,0x19,0x18,0x17,0x16,0x15,0x14,0x13,0x12,0x11,0x10,
 218          //0x1F,0x1D,0x1B,0x19,0x17,0x15,0x13,0x11,0x0F,0x0D,0x0B,0x09,0x07,0x05,0x03,0x01,
 219          };
 220          /*//;************************************************
 221          unsigned int code skid_value[256] =
 222          {
 223          0x0000,0x0010,0x0020,0x0030,0x0040,0x0050,0x0060,0x0070,0x0080,0x0090,0x00A0,0x00B0,0x00C0,0x00D0,0x00E0,0
             -x00F0,
 224          0x0100,0x0110,0x0120,0x0130,0x0140,0x0150,0x0160,0x0170,0x0180,0x0190,0x01A0,0x01B0,0x01C0,0x01D0,0x01E0,0
             -x01F0,
 225          0x0200,0x0210,0x0220,0x0230,0x0240,0x0250,0x0260,0x0270,0x0280,0x0290,0x02A0,0x02B0,0x02C0,0x02D0,0x02E0,0
             -x02F0,
 226          0x0300,0x0310,0x0320,0x0330,0x0340,0x0350,0x0360,0x0370,0x0380,0x0390,0x03A0,0x03B0,0x03C0,0x03D0,0x03E0,0
             -x03F0,
 227          0x0400,0x0410,0x0420,0x0430,0x0440,0x0450,0x0460,0x0470,0x0480,0x0490,0x04A0,0x04B0,0x04C0,0x04D0,0x04E0,0
             -x04F0,
 228          0x0500,0x0510,0x0520,0x0530,0x0540,0x0550,0x0560,0x0570,0x0580,0x0590,0x05A0,0x05B0,0x05C0,0x05D0,0x05E0,0
             -x05F0,
 229          0x0600,0x0610,0x0620,0x0630,0x0640,0x0650,0x0660,0x0670,0x0680,0x0690,0x06A0,0x06B0,0x06C0,0x06D0,0x06E0,0
             -x06F0,
 230          0x0700,0x0710,0x0720,0x0730,0x0740,0x0750,0x0760,0x0770,0x0780,0x0790,0x07A0,0x07B0,0x07C0,0x07D0,0x07E0,0
             -x07F0,
 231          0x0800,0x0810,0x0820,0x0830,0x0840,0x0850,0x0860,0x0870,0x0880,0x0890,0x08A0,0x08B0,0x08C0,0x08D0,0x08E0,0
             -x08F0,
 232          0x0900,0x0910,0x0920,0x0930,0x0940,0x0950,0x0960,0x0970,0x0980,0x0990,0x09A0,0x09B0,0x09C0,0x09D0,0x09E0,0
C51 COMPILER V8.06   75_8902                                                               01/04/2022 08:22:26 PAGE 5   

             -x09F0,
 233          0x0A00,0x0A10,0x0A20,0x0A30,0x0A40,0x0A50,0x0A60,0x0A70,0x0A80,0x0A90,0x0AA0,0x0AB0,0x0AC0,0x0AD0,0x0AE0,0
             -x0AF0,
 234          0x0B00,0x0B10,0x0B20,0x0B30,0x0B40,0x0B50,0x0B60,0x0B70,0x0B80,0x0B90,0x0BA0,0x0BB0,0x0BC0,0x0BD0,0x0BE0,0
             -x0BF0,
 235          0x0C00,0x0C10,0x0C20,0x0C30,0x0C40,0x0C50,0x0C60,0x0C70,0x0C80,0x0C90,0x0CA0,0x0CB0,0x0CC0,0x0CD0,0x0CE0,0
             -x0CF0,
 236          0x0D00,0x0D10,0x0D20,0x0D30,0x0D40,0x0D50,0x0D60,0x0D70,0x0D80,0x0D90,0x0DA0,0x0DB0,0x0DC0,0x0DD0,0x0DE0,0
             -x0DF0,
 237          0x0E00,0x0E10,0x0E20,0x0E30,0x0E40,0x0E50,0x0E60,0x0E70,0x0E80,0x0E90,0x0EA0,0x0EB0,0x0EC0,0x0ED0,0x0EE0,0
             -x0EF0,
 238          0x0F00,0x0F10,0x0F20,0x0F30,0x0F40,0x0F50,0x0F60,0x0F70,0x0F80,0x0F90,0x0FA0,0x0FB0,0x0FC0,0x0FD0,0x0FE0,0
             -x0FF0,
 239          };
 240          */
 241          unsigned int code skid_value[256] =
 242          {
 243          //-5VDC TO +5VDC
 244          0x0400,0x0408,0x0410,0x0418,0x0420,0x0428,0x0430,0x0438,0x0440,0x0448,0x0450,0x0458,0x0460,0x0468,0x0470,0
             -x0478,
 245          0x0480,0x0488,0x0490,0x0498,0x04A0,0x04A8,0x04B0,0x04B8,0x04C0,0x04C8,0x04D0,0x04D8,0x04E0,0x04E8,0x04F0,0
             -x04F8,
 246          0x0500,0x0508,0x0510,0x0518,0x0520,0x0528,0x0530,0x0538,0x0540,0x0548,0x0550,0x0558,0x0560,0x0568,0x0570,0
             -x0578,
 247          0x0580,0x0588,0x0590,0x0598,0x05A0,0x05A8,0x05B0,0x05B8,0x05C0,0x05C8,0x05D0,0x05D8,0x05E0,0x05E8,0x05F0,0
             -x05F8,
 248          0x0600,0x0608,0x0610,0x0618,0x0620,0x0628,0x0630,0x0638,0x0640,0x0648,0x0650,0x0658,0x0660,0x0668,0x0670,0
             -x0678,
 249          0x0680,0x0688,0x0690,0x0698,0x06A0,0x06A8,0x06B0,0x06B8,0x06C0,0x06C8,0x06D0,0x06D8,0x06E0,0x06E8,0x06F0,0
             -x06F8,
 250          0x0700,0x0708,0x0710,0x0718,0x0720,0x0728,0x0730,0x0738,0x0740,0x0748,0x0750,0x0758,0x0760,0x0768,0x0770,0
             -x0778,
 251          0x0780,0x0788,0x0790,0x0798,0x07A0,0x07A8,0x07B0,0x07B8,0x07C0,0x07C8,0x07D0,0x07D8,0x07E0,0x07E8,0x07F0,0
             -x07F8,
 252          0x0800,0x0808,0x0810,0x0818,0x0820,0x0828,0x0830,0x0838,0x0840,0x0848,0x0850,0x0858,0x0860,0x0868,0x0870,0
             -x0878,
 253          0x0880,0x0888,0x0890,0x0898,0x08A0,0x08A8,0x08B0,0x08B8,0x08C0,0x08C8,0x08D0,0x08D8,0x08E0,0x08E8,0x08F0,0
             -x08F8,
 254          0x0900,0x0908,0x0910,0x0918,0x0920,0x0928,0x0930,0x0938,0x0940,0x0948,0x0950,0x0958,0x0960,0x0968,0x0970,0
             -x0978,
 255          0x0980,0x0988,0x0990,0x0998,0x09A0,0x09A8,0x09B0,0x09B8,0x09C0,0x09C8,0x09D0,0x09D8,0x09E0,0x09E8,0x09F0,0
             -x09F8,
 256          0x0A00,0x0A08,0x0A10,0x0A18,0x0A20,0x0A28,0x0A30,0x0A38,0x0A40,0x0A48,0x0A50,0x0A58,0x0A60,0x0A68,0x0A70,0
             -x0A78,
 257          0x0A80,0x0A88,0x0A90,0x0A98,0x0AA0,0x0AA8,0x0AB0,0x0AB8,0x0AC0,0x0AC8,0x0AD0,0x0AD8,0x0AE0,0x0AE8,0x0AF0,0
             -x0AF8,
 258          0x0B00,0x0B08,0x0B10,0x0B18,0x0B20,0x0B28,0x0B30,0x0B38,0x0B40,0x0B48,0x0B50,0x0B58,0x0B60,0x0B68,0x0B70,0
             -x0B78,
 259          0x0B80,0x0B88,0x0B90,0x0B98,0x0BA0,0x0BA8,0x0BB0,0x0BB8,0x0BC0,0x0BC8,0x0BD0,0x0BD8,0x0BE0,0x0BE8,0x0BF0,0
             -x0BF8,
 260          
 261          };
 262          //;************************************************
 263          unsigned char code contrast_value[16] =
 264          {
 265          0x00,0x17,0x27,0x37,0x47,0x57,0x67,0x77,0x87,0x97,0xA7,0xB7,0xC7,0xD7,0xE7,0xFF,
 266          };
 267          //;************************************************
 268          void DELAY_LOOP_Wait(const unsigned int DELAY);
 269          void setup_serial(void);
 270          void setup_pwm(void);
 271          void setup_dac(void);
C51 COMPILER V8.06   75_8902                                                               01/04/2022 08:22:26 PAGE 6   

 272          void reset_everything(void);
 273          void transmit_data(void);
 274          void receive_data(void);
 275          void update_dimming(void);
 276          void send_status(void);
 277          void send_single_sw_status(void);
 278          void switch_send(void);
 279          void convert_to_transmit(void);
 280          void convert_to_receive(void);
 281          void update_dac(void);
 282          void update_skidball(void);
 283          void encoder(void);
 284          void clk_adc(void);
 285          void adc_read(void);
 286          void average_adc(void);
 287          void row_1(void);
 288          void row_2(void);
 289          void row_3(void);
 290          void row_4(void);
 291          void row_5(void);
 292          void send_command_values(void);
 293          void send_option_values(void);
 294          //;************************************************
 295          void main(void)
 296          {       setup_serial();
 297   1              setup_dac();
 298   1              setup_pwm();
 299   1              ewait = 0x07;   
 300   1              fpga_reset = 1;
 301   1              fpga_reset = 0;
 302   1              reset_bit = 1;
 303   1              reset_everything();
 304   1              P1      = 0x00;                                                 // configure as inputs 
 305   1              day_night = 0; 
 306   1              PBYTE[0x82] = 0x01; 
 307   1              j = 0;
 308   1              difference = 0;
 309   1              i = 0;
 310   1              update_display_contrast_bit = 1; 
 311   1      //;************************************************
 312   1              while(1)                                                
 313   1              {
 314   2      //      reset_everything();
 315   2      //      update_skidball();//;--------------------------
 316   2              
 317   2              update_dimming();
 318   2              update_skidball();//;--------------------------
 319   2              
 320   2              send_status();
 321   2              update_skidball();//;--------------------------
 322   2              
 323   2              send_single_sw_status();
 324   2              update_skidball();//;--------------------------
 325   2              
 326   2              update_dac();   
 327   2              update_skidball();//;-------------------------- 
 328   2              
 329   2              encoder();
 330   2              update_skidball();//;--------------------------
 331   2              
 332   2              row_1();
 333   2              update_skidball();//;--------------------------
C51 COMPILER V8.06   75_8902                                                               01/04/2022 08:22:26 PAGE 7   

 334   2              
 335   2              row_2();
 336   2              update_skidball();//;--------------------------
 337   2              
 338   2              row_3();
 339   2              update_skidball();//;--------------------------
 340   2              
 341   2              row_4();
 342   2              update_skidball();//;--------------------------
 343   2              
 344   2              row_5();
 345   2              update_skidball();//;--------------------------
 346   2              
 347   2              send_command_values();
 348   2              update_skidball();//;--------------------------
 349   2              
 350   2              send_option_values();
 351   2              update_skidball();//;--------------------------
 352   2      
 353   2              adc_read();
 354   2              update_skidball();//;--------------------------
 355   2              
 356   2              i++;
 357   2              if(i == 100)
 358   2              {
 359   3              average_adc();
 360   3              j = 0;
 361   3              difference = 0;
 362   3              i = 0;
 363   3              }
 364   2              }
 365   1      }
 366          //;************************************************
 367          void DELAY_LOOP_Wait(const unsigned int DELAY)
 368          {unsigned int x, y;
 369   1      for (x = 0; x <= DELAY; x++)
 370   1      {for (y = 0; y <= 255; y++);}}                  // DELAY_LOOP_Wait(255);
 371          //;************************************************
 372          void setup_serial(void)
 373          {       
 374   1              SCON    = 0x40;                                         // MODE1 UART
 375   1              T3CON   = 0x84;                                         // 19200K BPS   
 376   1              T3FD    = 0x01;                                         // DEFAULT IS 9600K BAUD
 377   1              REN     = 1;                                            // RECEIVE ENABLED
 378   1              ES              = 1;                                            // ENABLE SERIAL
 379   1              EA              = 1;                                            // ALL INTERRUPTS OK
 380   1              RI              = 0;                                            // CLR RECEIVE FLAG
 381   1              TI              = 0;                                            // CLR TRANSMIT FLAG
 382   1      }
 383          //;************************************************
 384          void setup_pwm(void)
 385          {
 386   1              PWMCON = 0x5F;                                          //
 387   1              PWM1L  = 0xFF;                                          // p2.6 resolution
 388   1              PWM1H  = 0xFF;                                          // p2.7 resolution
 389   1              PWM0L  = 0xFF;                                          // PWM0 DUTY CYCLE OUTPUT P2.6
 390   1              PWM0H  = 0xFF;                                          // PWM1 DUTY CYCLE OUTPUT P2.7
 391   1      }
 392          //;************************************************
 393          void setup_dac(void)
 394          {
 395   1              ADCCON1 = 0x80;                                         // TURN ADC ON / ADC HAS TO BE ON FOR DAC TO WORK
C51 COMPILER V8.06   75_8902                                                               01/04/2022 08:22:26 PAGE 8   

 396   1              DACCON  = 0xFF;                                         // SET DAC TO 8 BIT / 0 TO +3.3VDC AND TURN DAC0 ON
 397   1              DAC0L   = 0x00;                                         // RESET TO 0
 398   1              DAC0H   = 0x00;                                         // RESET TO 0
 399   1              DAC1L   = 0x00;                                         // RESET TO 0
 400   1              DAC1H   = 0x00;                                         // RESET TO 0
 401   1      }
 402          //;************************************************
 403          void reset_everything(void)
 404          {
 405   1      if(reset_bit)                                                   // check to see if reset flag is set
 406   1              {
 407   2              display_dim_byte = 0x00;
 408   2                                                                                      
 409   2              PWM0L = 0xFF;
 410   2              PWM0H = 0xFF;                                           // reset display dimming
 411   2      
 412   2              DAC0L   = 0x00;                                         // RESET TO 0
 413   2              DAC1L   = 0x87;                                         // SET TO MIDSCALE
 414   2      
 415   2              PBYTE[0x80] = 0xFF;                                     // DAC_Data_Out(7 downto 0) <= AddrData;
 416   2              PBYTE[0x81] = 0x07;                                     // DAC_Data_Out(11 downto 8)
 417   2      
 418   2              csa = 0;
 419   2              wr  = 0;
 420   2              wr  = 1;
 421   2              csa = 1;
 422   2              
 423   2              RS_fpga_firmware[0] = PBYTE[2];
 424   2              RS_fpga_firmware[1] = PBYTE[3];
 425   2              RS_fpga_firmware[2] = PBYTE[4];
 426   2              RS_fpga_firmware[3] = PBYTE[5];
 427   2      
 428   2              reset_bit = 0;
 429   2          }
 430   1      }
 431          //;************************************************
 432          void update_dac(void)
 433          {
 434   1      if(update_display_contrast_bit)
 435   1              {
 436   2      
 437   2              s_contrast_msn = contrast_msn; 
 438   2              s_contrast_lsn = contrast_lsn;
 439   2      
 440   2              tempreceive = contrast_msn;
 441   2              convert_to_receive();
 442   2              contrast_msn = tempreceive;
 443   2          
 444   2              tempreceive = contrast_lsn;
 445   2          convert_to_receive();
 446   2              contrast_lsn = tempreceive; 
 447   2              
 448   2              contrast_msn = (contrast_msn << 4) & 0xF0;
 449   2              contrast_lsn = contrast_lsn & 0x0F;
 450   2              
 451   2              contrast_byte = contrast_msn | contrast_lsn;
 452   2      
 453   2              DAC1L = contrast_value[contrast_byte];
 454   2      //;************************************************    
 455   2              if(echo == 0x31)                                                                //; send contrast echo
 456   2              {
 457   3              SBUF = CONTROL_COMMAND;
C51 COMPILER V8.06   75_8902                                                               01/04/2022 08:22:26 PAGE 9   

 458   3              transmit_data();
 459   3              SBUF = CONTRAST_ID;
 460   3              transmit_data();
 461   3              SBUF = s_contrast_msn;
 462   3              transmit_data();
 463   3              SBUF = s_contrast_lsn;
 464   3              transmit_data();
 465   3              SBUF = 0x0D;
 466   3              transmit_data();
 467   3              SBUF = 0x0A;
 468   3              transmit_data();
 469   3              }  
 470   2      //;************************************************
 471   2              update_display_contrast_bit = 0;
 472   2      //;************************************************
 473   2              }
 474   1      }
 475          //;************************************************
 476          void update_skidball(void)
 477          {
 478   1      if(update_skidball_bit)
 479   1      {
 480   2              s_skidball_msn = skidball_msn; 
 481   2              s_skidball_lsn = skidball_lsn;
 482   2      
 483   2          tempreceive = skidball_msn;
 484   2              convert_to_receive();
 485   2              skidball_msn = tempreceive;
 486   2          
 487   2              tempreceive = skidball_lsn;
 488   2          convert_to_receive();
 489   2              skidball_lsn = tempreceive; 
 490   2              
 491   2              skidball_msn = (skidball_msn << 4) & 0xF0;
 492   2              skidball_lsn = skidball_lsn & 0x0F;
 493   2              
 494   2              skidball_byte = skidball_msn | skidball_lsn;
 495   2      
 496   2              look_up_value = skid_value[skidball_byte];
 497   2      
 498   2              tempskidlo = (look_up_value & 0xFF);
 499   2              tempskidhi = (look_up_value >> 8) & 0x0F;
 500   2      
 501   2              PBYTE[0x80] = tempskidlo;                                               //; DAC_Data_Out(7 downto 0) <= AddrData;
 502   2              PBYTE[0x81] = tempskidhi;                                               //; DAC_Data_Out(11 downto 8)
 503   2      
 504   2              csa = 0;
 505   2              wr  = 0;
 506   2              wr  = 1;
 507   2              csa = 1;
 508   2      //;************************************************    
 509   2              if(echo == 0x31)                                                                //; send skidball echo
 510   2              {
 511   3              SBUF = CONTROL_COMMAND;
 512   3              transmit_data();
 513   3              SBUF = SKIDBALL_ID;
 514   3              transmit_data();
 515   3              SBUF = s_skidball_msn;
 516   3              transmit_data();
 517   3              SBUF = s_skidball_lsn;
 518   3              transmit_data();
 519   3              SBUF = 0x0D;
C51 COMPILER V8.06   75_8902                                                               01/04/2022 08:22:26 PAGE 10  

 520   3              transmit_data();
 521   3              SBUF = 0x0A;
 522   3              transmit_data();
 523   3              }
 524   2      //;************************************************     
 525   2              update_skidball_bit = 0;
 526   2      //;************************************************
 527   2              }
 528   1      }
 529          //;************************************************
 530          void encoder(void)
 531          {
 532   1              Abyte = PBYTE[0x35];
 533   1              if(Abyte != enc_byte)
 534   1              {
 535   2              enc_byte = Abyte;
 536   2      
 537   2              enc_msn = (enc_byte >> 4) & 0x0F;
 538   2              enc_lsn = enc_byte & 0x0F;    
 539   2              
 540   2              temptransmit = enc_msn;
 541   2              convert_to_transmit();
 542   2              enc_msn = temptransmit;
 543   2      
 544   2              temptransmit = enc_lsn;
 545   2              convert_to_transmit();
 546   2              enc_lsn = temptransmit;
 547   2              
 548   2      if(realtime == 0x30)
 549   2              {
 550   3              SBUF = ENC_POT_STATUS;          //;0x28
 551   3              transmit_data();
 552   3              SBUF = ENC_ID;                          //;0x58                         
 553   3              transmit_data();
 554   3              SBUF = enc_msn;                         //;0-9,A-F      
 555   3              transmit_data();
 556   3              SBUF = enc_lsn;                         //;0-9,A-F      
 557   3              transmit_data();
 558   3              SBUF = 0x0D;                            //;Return       
 559   3              transmit_data();
 560   3              SBUF = 0x0A;                            //;New Line     
 561   3              transmit_data();
 562   3              }
 563   2              }
 564   1      if(send_encoder_status)
 565   1          {
 566   2              SBUF = ENC_POT_STATUS;          //;0x28
 567   2              transmit_data();
 568   2              SBUF = ENC_ID;                          //;0x58                         
 569   2              transmit_data();
 570   2              SBUF = enc_msn;                         //;0-9,A-F      
 571   2              transmit_data();
 572   2              SBUF = enc_lsn;                         //;0-9,A-F      
 573   2              transmit_data();
 574   2              SBUF = 0x0D;                            //;Return       
 575   2              transmit_data();
 576   2              SBUF = 0x0A;                            //;New Line     
 577   2              transmit_data();
 578   2              send_encoder_status = 0;
 579   2              
 580   2              if(echo == 0x31)                                                                //; send encoder echo
 581   2              {
C51 COMPILER V8.06   75_8902                                                               01/04/2022 08:22:26 PAGE 11  

 582   3              DELAY_LOOP_Wait(100);
 583   3              SBUF = ENC_POT_STATUS;          //;0x28
 584   3              transmit_data();
 585   3              SBUF = ENC_ID;                          //;0x58                         
 586   3              transmit_data();
 587   3              SBUF = 0x0D;                            //;Return       
 588   3              transmit_data();
 589   3              SBUF = 0x0A;                            //;New Line     
 590   3              transmit_data();
 591   3              }       
 592   2              }
 593   1      }
 594          //;************************************************
 595          void keyboardsend(void)
 596          {if(realtime == 0x30)
 597   1              {
 598   2              SBUF = SWITCH_STATUS;
 599   2              transmit_data();
 600   2              SBUF = KEYADDRESS;
 601   2              transmit_data();
 602   2              SBUF = KEYDATA;
 603   2              transmit_data();
 604   2              SBUF = 0x0D;
 605   2              transmit_data();
 606   2              SBUF = 0x0A;
 607   2              transmit_data();        
 608   2              }
 609   1      }
 610          //;************************************************
 611          void row_1(void)
 612          {unsigned int i;
 613   1              for(i = 0; i <= 8; i++)                         // LOAD DEBOUNCE COUNT
 614   1                      {Abyte = PBYTE[0x30];                           // 
 615   2                       Abyte = ~Abyte;                                        // COMPLIMENT THE DATA IN ABYTE
 616   2                       Bbyte = Abyte;}                                        // STORE A COPY OF IT IN Bbyte
 617   1              if(Abyte != SWOLD1)                                             // has there been a change      
 618   1               {Abyte = Abyte ^ SWOLD1;                               // XOR new value with old to see what changed
 619   2                      if(Abyte != 0)                                          //
 620   2                      {SWOLD1 = Bbyte;}                                       // change detected store new value for comparison next time around
 621   2      //41                                                                    
 622   2                if(Abyte0 != 1)goto CHK_42;
 623   2                if(Bbyte0 == 1)                                               
 624   2                {
 625   3                 KEYADDRESS = PB_41;
 626   3                 KEYDATA = BUTTON_PRESSED;
 627   3                 PB_41_Status = BUTTON_PRESSED;                                               
 628   3                 keyboardsend();}
 629   2                if(Bbyte0 == 0)                                               
 630   2                {
 631   3                 KEYADDRESS = PB_41;
 632   3                 KEYDATA = BUTTON_RELEASED;
 633   3                 PB_41_Status = BUTTON_RELEASED;                                              
 634   3                 keyboardsend();}                                     
 635   2      CHK_42:                                                                 
 636   2                if(Abyte1 != 1)goto CHK_43;
 637   2                if(Bbyte1 == 1)                                               
 638   2                {
 639   3                 KEYADDRESS = PB_42;
 640   3                 KEYDATA = BUTTON_PRESSED;
 641   3                 PB_42_Status = BUTTON_PRESSED;                                               
 642   3                 keyboardsend();}
 643   2                if(Bbyte1 == 0)                                               
C51 COMPILER V8.06   75_8902                                                               01/04/2022 08:22:26 PAGE 12  

 644   2                {
 645   3                 KEYADDRESS = PB_42;
 646   3                 KEYDATA = BUTTON_RELEASED;
 647   3                 PB_42_Status = BUTTON_RELEASED;                                              
 648   3                 keyboardsend();}     
 649   2      CHK_43:                                                                 
 650   2                if(Abyte2 != 1)goto CHK_44;
 651   2                if(Bbyte2 == 1)                                               
 652   2                {
 653   3                 KEYADDRESS = PB_43;
 654   3                 KEYDATA = BUTTON_PRESSED;
 655   3                 PB_43_Status = BUTTON_PRESSED;                                               
 656   3                 keyboardsend();}
 657   2                if(Bbyte2 == 0)                                               
 658   2                {
 659   3                 KEYADDRESS = PB_43;
 660   3                 KEYDATA = BUTTON_RELEASED;
 661   3                 PB_43_Status = BUTTON_RELEASED;                                              
 662   3                 keyboardsend();}     
 663   2      CHK_44:                                                                 
 664   2                if(Abyte3 != 1)goto CHK_45;
 665   2                if(Bbyte3 == 1)                                               
 666   2                {
 667   3                 KEYADDRESS = PB_44;
 668   3                 KEYDATA = BUTTON_PRESSED;
 669   3                 PB_44_Status = BUTTON_PRESSED;                                               
 670   3                 keyboardsend();}
 671   2                if(Bbyte3 == 0)                                               
 672   2                {
 673   3                 KEYADDRESS = PB_44;
 674   3                 KEYDATA = BUTTON_RELEASED;
 675   3                 PB_44_Status = BUTTON_RELEASED;                                              
 676   3                 keyboardsend();}             
 677   2      CHK_45:                                                                 
 678   2                if(Abyte4 != 1)goto CHK_46;
 679   2                if(Bbyte4 == 1)                                               
 680   2                {
 681   3                 KEYADDRESS = PB_45;
 682   3                 KEYDATA = BUTTON_PRESSED;
 683   3                 PB_45_Status = BUTTON_PRESSED;                                               
 684   3                 keyboardsend();}
 685   2                if(Bbyte4 == 0)                                               
 686   2                {
 687   3                 KEYADDRESS = PB_45;
 688   3                 KEYDATA = BUTTON_RELEASED;
 689   3                 PB_45_Status = BUTTON_RELEASED;                                              
 690   3                 keyboardsend();}     
 691   2      CHK_46:                                                                 
 692   2                if(Abyte5 != 1)return;
 693   2                if(Bbyte5 == 1)                                               
 694   2                {
 695   3                 KEYADDRESS = PB_46;
 696   3                 KEYDATA = BUTTON_PRESSED;
 697   3                 PB_46_Status = BUTTON_PRESSED;                                               
 698   3                 keyboardsend();}
 699   2                if(Bbyte5 == 0)                                               
 700   2                {
 701   3                 KEYADDRESS = PB_46;
 702   3                 KEYDATA = BUTTON_RELEASED;
 703   3                 PB_46_Status = BUTTON_RELEASED;                                              
 704   3                 keyboardsend();}             
 705   2              }                                                                               
C51 COMPILER V8.06   75_8902                                                               01/04/2022 08:22:26 PAGE 13  

 706   1      }
 707          //;************************************************
 708          void row_2(void)
 709          {unsigned int i;
 710   1              for(i = 0; i <= 8; i++)                         // LOAD DEBOUNCE COUNT
 711   1                      {Abyte = PBYTE[0x31];                           // 
 712   2                       Abyte = ~Abyte;                                        // COMPLIMENT THE DATA IN ABYTE
 713   2                       Bbyte = Abyte;}                                        // STORE A COPY OF IT IN Bbyte
 714   1              if(Abyte != SWOLD2)                                             // has there been a change      
 715   1               {Abyte = Abyte ^ SWOLD2;                               // XOR new value with old to see what changed
 716   2                      if(Abyte != 0)                                          //
 717   2                      {SWOLD2 = Bbyte;}                                       // change detected store new value for comparison next time around
 718   2      //47                                                                    
 719   2                if(Abyte0 != 1)goto CHK_48;
 720   2                if(Bbyte0 == 1)                                               
 721   2                {
 722   3                 KEYADDRESS = PB_47;
 723   3                 KEYDATA = BUTTON_PRESSED;
 724   3                 PB_47_Status = BUTTON_PRESSED;                                               
 725   3                 keyboardsend();}
 726   2                if(Bbyte0 == 0)                                               
 727   2                {
 728   3                 KEYADDRESS = PB_47;
 729   3                 KEYDATA = BUTTON_RELEASED; 
 730   3                 PB_47_Status = BUTTON_RELEASED;                                              
 731   3                 keyboardsend();}                                     
 732   2      CHK_48:                                                                 
 733   2                if(Abyte1 != 1)goto CHK_49;
 734   2                if(Bbyte1 == 1)                                               
 735   2                {
 736   3                 KEYADDRESS = PB_48;
 737   3                 KEYDATA = BUTTON_PRESSED;
 738   3                 PB_48_Status = BUTTON_PRESSED;                                               
 739   3                 keyboardsend();}
 740   2                if(Bbyte1 == 0)                                               
 741   2                {
 742   3                 KEYADDRESS = PB_48;
 743   3                 KEYDATA = BUTTON_RELEASED;
 744   3                 PB_48_Status = BUTTON_RELEASED;                                              
 745   3                 keyboardsend();}     
 746   2      CHK_49:                                                                 
 747   2                if(Abyte2 != 1)goto CHK_4A;
 748   2                if(Bbyte2 == 1)                                               
 749   2                {
 750   3                 KEYADDRESS = PB_49;
 751   3                 KEYDATA = BUTTON_PRESSED;
 752   3                 PB_49_Status = BUTTON_PRESSED;                                               
 753   3                 keyboardsend();}
 754   2                if(Bbyte2 == 0)                                               
 755   2                {
 756   3                 KEYADDRESS = PB_49;
 757   3                 KEYDATA = BUTTON_RELEASED;
 758   3                 PB_49_Status = BUTTON_RELEASED;                                              
 759   3                 keyboardsend();}     
 760   2      CHK_4A:                                                                 
 761   2                if(Abyte3 != 1)goto CHK_4B;
 762   2                if(Bbyte3 == 1)                                               
 763   2                {
 764   3                 KEYADDRESS = PB_4A;
 765   3                 KEYDATA = BUTTON_PRESSED;
 766   3                 PB_4A_Status = BUTTON_PRESSED;                                               
 767   3                 keyboardsend();}
C51 COMPILER V8.06   75_8902                                                               01/04/2022 08:22:26 PAGE 14  

 768   2                if(Bbyte3 == 0)                                               
 769   2                {
 770   3                 KEYADDRESS = PB_4A;
 771   3                 KEYDATA = BUTTON_RELEASED;
 772   3                 PB_4A_Status = BUTTON_RELEASED;                                              
 773   3                 keyboardsend();}             
 774   2      CHK_4B:                                                                 
 775   2                if(Abyte4 != 1)return;
 776   2                if(Bbyte4 == 1)                                               
 777   2                {
 778   3                 KEYADDRESS = PB_4B;
 779   3                 KEYDATA = BUTTON_PRESSED;
 780   3                 PB_4B_Status = BUTTON_PRESSED;                                               
 781   3                 keyboardsend();}
 782   2                if(Bbyte4 == 0)                                               
 783   2                {
 784   3                 KEYADDRESS = PB_4B;
 785   3                 KEYDATA = BUTTON_RELEASED;
 786   3                 PB_4B_Status = BUTTON_RELEASED;                                              
 787   3                 keyboardsend();}     
 788   2              }                                                                               
 789   1      }
 790          //;************************************************
 791          void row_3(void)
 792          {unsigned int i;
 793   1              for(i = 0; i <= 8; i++)                         // LOAD DEBOUNCE COUNT
 794   1                      {Abyte = PBYTE[0x32];                           // 
 795   2                       Abyte = ~Abyte;                                        // COMPLIMENT THE DATA IN ABYTE
 796   2                       Bbyte = Abyte;}                                        // STORE A COPY OF IT IN Bbyte
 797   1              if(Abyte != SWOLD3)                                             // has there been a change      
 798   1               {Abyte = Abyte ^ SWOLD3;                               // XOR new value with old to see what changed
 799   2                      if(Abyte != 0)                                          //
 800   2                      {SWOLD3 = Bbyte;}                                       // change detected store new value for comparison next time around
 801   2      //4C                                                                    
 802   2                if(Abyte0 != 1)goto CHK_4D;
 803   2                if(Bbyte0 == 1)                                               
 804   2                {
 805   3                 KEYADDRESS = PB_4C;
 806   3                 KEYDATA = BUTTON_PRESSED;
 807   3                 PB_4C_Status = BUTTON_PRESSED;                                               
 808   3                 keyboardsend();}
 809   2                if(Bbyte0 == 0)                                               
 810   2                {
 811   3                 KEYADDRESS = PB_4C;
 812   3                 KEYDATA = BUTTON_RELEASED;
 813   3                 PB_4C_Status = BUTTON_RELEASED;                                              
 814   3                 keyboardsend();}                                     
 815   2      CHK_4D:                                                                 
 816   2                if(Abyte1 != 1)goto CHK_4E;
 817   2                if(Bbyte1 == 1)                                               
 818   2                {
 819   3                 KEYADDRESS = PB_4D;
 820   3                 KEYDATA = BUTTON_PRESSED;
 821   3                 PB_4D_Status = BUTTON_PRESSED;                                               
 822   3                 keyboardsend();}
 823   2                if(Bbyte1 == 0)                                               
 824   2                {
 825   3                 KEYADDRESS = PB_4D;
 826   3                 KEYDATA = BUTTON_RELEASED;
 827   3                 PB_4D_Status = BUTTON_RELEASED;                                              
 828   3                 keyboardsend();}     
 829   2      CHK_4E:                                                                 
C51 COMPILER V8.06   75_8902                                                               01/04/2022 08:22:26 PAGE 15  

 830   2                if(Abyte2 != 1)goto CHK_4F;
 831   2                if(Bbyte2 == 1)                                               
 832   2                {
 833   3                 KEYADDRESS = PB_4E;
 834   3                 KEYDATA = BUTTON_PRESSED;
 835   3                 PB_4E_Status = BUTTON_PRESSED;                                               
 836   3                 keyboardsend();}
 837   2                if(Bbyte2 == 0)                                               
 838   2                {
 839   3                 KEYADDRESS = PB_4E;
 840   3                 KEYDATA = BUTTON_RELEASED;
 841   3                 PB_4E_Status = BUTTON_RELEASED;                                              
 842   3                 keyboardsend();}     
 843   2      CHK_4F:                                                                 
 844   2                if(Abyte3 != 1)goto CHK_50;
 845   2                if(Bbyte3 == 1)                                               
 846   2                {
 847   3                 KEYADDRESS = PB_4F;
 848   3                 KEYDATA = BUTTON_PRESSED;
 849   3                 PB_4F_Status = BUTTON_PRESSED;                                               
 850   3                 keyboardsend();}
 851   2                if(Bbyte3 == 0)                                               
 852   2                {
 853   3                 KEYADDRESS = PB_4F;
 854   3                 KEYDATA = BUTTON_RELEASED;
 855   3                 PB_4F_Status = BUTTON_RELEASED;                                              
 856   3                 keyboardsend();}             
 857   2      CHK_50:                                                                 
 858   2                if(Abyte4 != 1)goto CHK_51;
 859   2                if(Bbyte4 == 1)                                               
 860   2                {
 861   3                 KEYADDRESS = PB_50;
 862   3                 KEYDATA = BUTTON_PRESSED;
 863   3                 PB_50_Status = BUTTON_PRESSED;                                               
 864   3                 keyboardsend();}
 865   2                if(Bbyte4 == 0)                                               
 866   2                {
 867   3                 KEYADDRESS = PB_50;
 868   3                 KEYDATA = BUTTON_RELEASED;
 869   3                 PB_50_Status = BUTTON_RELEASED;                                              
 870   3                 keyboardsend();}     
 871   2      CHK_51:                                                                 
 872   2                if(Abyte5 != 1)return;
 873   2                if(Bbyte5 == 1)                                               
 874   2                {
 875   3                 KEYADDRESS = PB_51;
 876   3                 KEYDATA = BUTTON_PRESSED;
 877   3                 PB_51_Status = BUTTON_PRESSED;                                               
 878   3                 keyboardsend();}
 879   2                if(Bbyte5 == 0)                                               
 880   2                {
 881   3                 KEYADDRESS = PB_51;
 882   3                 KEYDATA = BUTTON_RELEASED; 
 883   3                 PB_51_Status = BUTTON_RELEASED;                                              
 884   3                 keyboardsend();}             
 885   2              }                                                                               
 886   1      }
 887          //;************************************************
 888          void row_4(void)
 889          {unsigned int i;
 890   1              for(i = 0; i <= 8; i++)                         // LOAD DEBOUNCE COUNT
 891   1                      {Abyte = PBYTE[0x33];                           // 
C51 COMPILER V8.06   75_8902                                                               01/04/2022 08:22:26 PAGE 16  

 892   2                       Abyte = ~Abyte;                                        // COMPLIMENT THE DATA IN ABYTE
 893   2                       Bbyte = Abyte;}                                        // STORE A COPY OF IT IN Bbyte
 894   1              if(Abyte != SWOLD4)                                             // has there been a change      
 895   1               {Abyte = Abyte ^ SWOLD4;                               // XOR new value with old to see what changed
 896   2                      if(Abyte != 0)                                          //
 897   2                      {SWOLD4 = Bbyte;}                                       // change detected store new value for comparison next time around
 898   2      //52                                                                    
 899   2                if(Abyte0 != 1)return;
 900   2                if(Bbyte0 == 1)                                               
 901   2                {
 902   3                 KEYADDRESS = BRT_PB;
 903   3                 KEYDATA = BUTTON_PRESSED;
 904   3                 BRT_PB_Status = BUTTON_PRESSED;                                              
 905   3                 keyboardsend();}
 906   2                if(Bbyte0 == 0)                                               
 907   2                {
 908   3                 KEYADDRESS = BRT_PB;
 909   3                 KEYDATA = BUTTON_RELEASED;
 910   3                 BRT_PB_Status = BUTTON_RELEASED;                                             
 911   3                 keyboardsend();}     
 912   2                }
 913   1      }
 914          //;************************************************
 915          void row_5(void)
 916          {unsigned int i;
 917   1              for(i = 0; i <= 8; i++)                         // LOAD DEBOUNCE COUNT
 918   1                      {Abyte = PBYTE[0x34];                           // 
 919   2                       Abyte = ~Abyte;                                        // COMPLIMENT THE DATA IN ABYTE
 920   2                       Bbyte = Abyte;}                                        // STORE A COPY OF IT IN Bbyte
 921   1              if(Abyte != SWOLD5)                                             // has there been a change      
 922   1               {Abyte = Abyte ^ SWOLD5;                               // XOR new value with old to see what changed
 923   2                      if(Abyte != 0)                                          //
 924   2                      {SWOLD5 = Bbyte;}                                       // change detected store new value for comparison next time around
 925   2      //53                                                                    
 926   2                if(Abyte0 != 1)return;
 927   2                if(Bbyte0 == 1)                                               
 928   2                {
 929   3                 KEYADDRESS = ENC_PB;
 930   3                 KEYDATA = BUTTON_PRESSED;
 931   3                 ENC_PB_Status = BUTTON_PRESSED;                                              
 932   3                 keyboardsend();}
 933   2                if(Bbyte0 == 0)                                               
 934   2                {
 935   3                 KEYADDRESS = ENC_PB;
 936   3                 KEYDATA = BUTTON_RELEASED;
 937   3                 ENC_PB_Status = BUTTON_RELEASED;                                             
 938   3                 keyboardsend();}     
 939   2                }
 940   1      }
 941          //;************************************************
 942          void transmit_data(void)
 943          {
 944   1              while(!TI);             
 945   1              TI = 0;
 946   1      }
 947          //;************************************************
 948          void receive_data(void)
 949          {
 950   1              while(!RI);             
 951   1              RI = 0;
 952   1      }
 953          //;************************************************
C51 COMPILER V8.06   75_8902                                                               01/04/2022 08:22:26 PAGE 17  

 954          void convert_to_receive(void)
 955          {
 956   1            if (tempreceive < 0x41)
 957   1            tempreceive = (tempreceive - 0x30);
 958   1            else
 959   1            tempreceive = (tempreceive - 0x37);
 960   1      }
 961          //;************************************************
 962          void convert_to_transmit(void)
 963          {
 964   1            if (temptransmit < 0x0A)
 965   1            temptransmit = (temptransmit + 0x30);
 966   1            else
 967   1            temptransmit = (temptransmit + 0x37);
 968   1      }
 969          //;************************************************
 970          void clk_adc(void)
 971          {
 972   1              ADC_clk = 1;
 973   1              ADC_clk = 0;
 974   1      }
 975          //;************************************************
 976          void adc_read(void)
 977          {       
 978   1      //unsigned long int i,j;
 979   1              //j = 0;
 980   1              //difference = 0;
 981   1              
 982   1              //for(i = 0; i < 256; i++)
 983   1              //{
 984   1              ADC_clk = 1;                                                                    // adc clock high
 985   1          ADC_cs = 1;                                                                         // adc cs high
 986   1          ADC_cs = 0;                                                                         // adc chip select lo
 987   1      while(ADC_data == 0);                                                           // wait for end of conversion
 988   1                      clk_adc();                                                                      //
 989   1                      clk_adc();                                                                      //
 990   1                      clk_adc();                                                                      //
 991   1                      clk_adc();                                                                      // channel id
 992   1                      Abyte = 0x00;
 993   1                      clk_adc();
 994   1                      Abyte7 = ADC_data;              
 995   1                      clk_adc();
 996   1                      Abyte6 = ADC_data;
 997   1                      clk_adc();
 998   1                      Abyte5 = ADC_data;              
 999   1                      clk_adc();
1000   1                      Abyte4 = ADC_data;
1001   1                      clk_adc();
1002   1                      Abyte3 = ADC_data;              
1003   1                      clk_adc(); 
1004   1                      Abyte2 = ADC_data;
1005   1                      clk_adc(); 
1006   1                      Abyte1 = ADC_data;
1007   1                      clk_adc(); 
1008   1                      Abyte0 = ADC_data;              
1009   1                      clk_adc();                                                                      // d3           
1010   1                      clk_adc();                                                                      // d2           
1011   1                      clk_adc();                                                                      // d1
1012   1                      clk_adc();                                                                      // d0
1013   1                      j += Abyte;
1014   1              //}
1015   1      }
C51 COMPILER V8.06   75_8902                                                               01/04/2022 08:22:26 PAGE 18  

1016          //;************************************************
1017          void average_adc(void)
1018          {
1019   1      //      j = (j >> 8);                                                           // divide by ?
1020   1              j = (j / 100);
1021   1              Abyte = j;                                                                      // new adc value
1022   1              new_brt_byte = Abyte;
1023   1      //;************************************************     
1024   1              if(new_brt_byte != old_brt_byte)
1025   1              {
1026   2              Bbyte = new_brt_byte;                                                   // old value to B
1027   2              Bbyte -= old_brt_byte;                                                  // subtract new from old
1028   2      
1029   2      //;************************************************
1030   2              if(Bbyte7 == 0)                                                         // difference is positive value
1031   2              {
1032   3              difference = Bbyte;
1033   3              }
1034   2      //;************************************************             
1035   2              if(Bbyte7 == 1)                                                         // negative value convert 2's complement
1036   2              {                                                                       
1037   3              Bbyte = ~Bbyte;                                                 // begin 2's complement conversion
1038   3              Bbyte = Bbyte + 1;                                              // add 1 to finsish process
1039   3              difference = Bbyte;
1040   3              }
1041   2      //;************************************************                             
1042   2              if(difference > 0x01)                                   // update pwm if change is greater than 1xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
             -xxxxxxxxxxxxxxxx              
1043   2              {
1044   3      //;************************************************     
1045   3              if(brt_control == 0x30)
1046   3              {
1047   4      //;************************************************     
1048   4              if(new_brt_byte == 0x00)
1049   4              {PBYTE[0x82] = 0x00;}
1050   4              else
1051   4              {PBYTE[0x82] = 0x01;}
1052   4      //;************************************************     
1053   4              if(new_brt_byte < 0x80)
1054   4              {
1055   5              day_night = 0;
1056   5              PWM0L = dim_value[new_brt_byte];
1057   5              PWM0H = ~bezel_dim_byte;                
1058   5              }
1059   4      //;************************************************
1060   4      if((old_brt_byte < 0x80) && (new_brt_byte > 0x7F))
1061   4              {   
1062   5          PBYTE[0x82] = 0x00;
1063   5              PWM0L = dim_value[new_brt_byte];        
1064   5              PWM0H = ~bezel_dim_byte;
1065   5              DELAY_LOOP_Wait(25);
1066   5              day_night = 1;
1067   5          DELAY_LOOP_Wait(25);
1068   5              PBYTE[0x82] = 0x01;
1069   5              }                                                        
1070   4      //;************************************************     
1071   4              if(Abyte > 0x7F)
1072   4              {
1073   5              day_night = 1;
1074   5              PWM0L = dim_value[new_brt_byte];                
1075   5              PWM0H = ~bezel_dim_byte;                
1076   5              }
C51 COMPILER V8.06   75_8902                                                               01/04/2022 08:22:26 PAGE 19  

1077   4              }
1078   3              //}
1079   3      //;************************************************
1080   3              brt_msn = (new_brt_byte >> 4) & 0x0F;
1081   3              brt_lsn = new_brt_byte & 0x0F;    
1082   3              
1083   3              temptransmit = brt_msn;
1084   3              convert_to_transmit();
1085   3              brt_msn = temptransmit;
1086   3      
1087   3              temptransmit = brt_lsn;
1088   3              convert_to_transmit();
1089   3              brt_lsn = temptransmit;
1090   3      //;************************************************
1091   3      if(realtime == 0x30)
1092   3              {
1093   4              SBUF = ENC_POT_STATUS;          //;0x28
1094   4              transmit_data();
1095   4              SBUF = POT_ID;                          //;0x58                         
1096   4              transmit_data();
1097   4              SBUF = brt_msn;                         //;0-9,A-F      
1098   4              transmit_data();
1099   4              SBUF = brt_lsn;                         //;0-9,A-F      
1100   4              transmit_data();
1101   4              SBUF = 0x0D;                            //;Return       
1102   4              transmit_data();
1103   4              SBUF = 0x0A;                            //;New Line     
1104   4              transmit_data();
1105   4              }
1106   3              old_brt_byte = new_brt_byte;    
1107   3              }
1108   2              }
1109   1      //;************************************************
1110   1      if(send_pot_status)
1111   1          {
1112   2              SBUF = ENC_POT_STATUS;          //;0x28
1113   2              transmit_data();
1114   2              SBUF = POT_ID;                          //;0x58                         
1115   2              transmit_data();
1116   2              SBUF = brt_msn;                         //;0-9,A-F      
1117   2              transmit_data();
1118   2              SBUF = brt_lsn;                         //;0-9,A-F      
1119   2              transmit_data();
1120   2              SBUF = 0x0D;                            //;Return       
1121   2              transmit_data();
1122   2              SBUF = 0x0A;                            //;New Line     
1123   2              transmit_data();
1124   2              send_pot_status = 0;
1125   2      //;************************************************
1126   2              if(echo == 0x31)                                                                //; send encoder echo
1127   2              {
1128   3              DELAY_LOOP_Wait(100);
1129   3              SBUF = ENC_POT_STATUS;          //;0x28
1130   3              transmit_data();
1131   3              SBUF = POT_ID;                          //;0x58                         
1132   3              transmit_data();
1133   3              SBUF = 0x0D;                            //;Return       
1134   3              transmit_data();
1135   3              SBUF = 0x0A;                            //;New Line     
1136   3              transmit_data();
1137   3              }       
1138   2              }
C51 COMPILER V8.06   75_8902                                                               01/04/2022 08:22:26 PAGE 20  

1139   1      //;************************************************
1140   1      }
1141          //;************************************************
1142          void update_dimming(void)
1143          {
1144   1      if(brt_control == 0x31)
1145   1      {
1146   2      if(update_display_dimming_bit)
1147   2              {
1148   3              s_display_dim_msn = display_dim_msn;
1149   3              s_display_dim_lsn = display_dim_lsn;
1150   3      
1151   3              tempreceive = display_dim_msn;
1152   3              convert_to_receive();
1153   3              display_dim_msn = tempreceive;
1154   3          
1155   3              tempreceive = display_dim_lsn;
1156   3          convert_to_receive();
1157   3              display_dim_lsn = tempreceive; 
1158   3              
1159   3              display_dim_msn = (display_dim_msn << 4) & 0xF0;
1160   3              display_dim_lsn = display_dim_lsn & 0x0F;
1161   3              
1162   3              display_dim_byte = display_dim_msn | display_dim_lsn;
1163   3      //;************************************************     
1164   3              if(display_dim_byte == 0x00)
1165   3              {PBYTE[0x82] = 0x00;}
1166   3              else
1167   3              {PBYTE[0x82] = 0x01;}
1168   3      //;************************************************     
1169   3              if(display_dim_byte < 0x80)
1170   3              {
1171   4              day_night = 0;
1172   4              PWM0L = dim_value[display_dim_byte];
1173   4              PWM0H = ~bezel_dim_byte;                
1174   4              }
1175   3      //;************************************************
1176   3      if((old_display_dim_byte < 0x80) && (display_dim_byte > 0x7F))
1177   3              {   
1178   4          PBYTE[0x82] = 0x00;
1179   4              PWM0L = dim_value[display_dim_byte];    
1180   4              PWM0H = ~bezel_dim_byte;
1181   4              DELAY_LOOP_Wait(25);
1182   4              day_night = 1;
1183   4          DELAY_LOOP_Wait(25);
1184   4              PBYTE[0x82] = 0x01;
1185   4              }                                                        
1186   3      //;************************************************     
1187   3              if(display_dim_byte > 0x7F)
1188   3              {
1189   4              day_night = 1;
1190   4              PWM0L = dim_value[display_dim_byte];            
1191   4              PWM0H = ~bezel_dim_byte;                
1192   4              }
1193   3      //;************************************************
1194   3              old_display_dim_byte = display_dim_byte;
1195   3      //;************************************************    
1196   3              if(echo == 0x31)                                                                //; send display dim echo
1197   3              {
1198   4              SBUF = CONTROL_COMMAND;
1199   4              transmit_data();
1200   4              SBUF = DISPLAY_DIM_ID;
C51 COMPILER V8.06   75_8902                                                               01/04/2022 08:22:26 PAGE 21  

1201   4              transmit_data();
1202   4              SBUF = s_display_dim_msn;
1203   4              transmit_data();
1204   4              SBUF = s_display_dim_lsn;
1205   4              transmit_data();
1206   4              SBUF = 0x0D;
1207   4              transmit_data();
1208   4              SBUF = 0x0A;
1209   4              transmit_data();
1210   4              }       
1211   3      //;************************************************     
1212   3              update_display_dimming_bit = 0;
1213   3      //;************************************************
1214   3              }
1215   2      }
1216   1      //;************************************************
1217   1      if(update_bezel_dimming_bit)
1218   1              {
1219   2              s_bezel_dim_msn = bezel_dim_msn;
1220   2              s_bezel_dim_lsn = bezel_dim_lsn;
1221   2      
1222   2              tempreceive = bezel_dim_msn;
1223   2              convert_to_receive();
1224   2              bezel_dim_msn = tempreceive;
1225   2          
1226   2              tempreceive = bezel_dim_lsn;
1227   2          convert_to_receive();
1228   2              bezel_dim_lsn = tempreceive; 
1229   2              
1230   2              bezel_dim_msn = (bezel_dim_msn << 4) & 0xF0;
1231   2              bezel_dim_lsn = bezel_dim_lsn & 0x0F;
1232   2              
1233   2              bezel_dim_byte = bezel_dim_msn | bezel_dim_lsn;
1234   2              
1235   2              //PWM0L = dim_value[display_dim_byte];
1236   2              //PWM0H = ~bezel_dim_byte;
1237   2              
1238   2              if(brt_control == 0x30)
1239   2              {
1240   3              PWM0L = dim_value[old_brt_byte];
1241   3              //display_dim_byte = dim_value[brt_byte];
1242   3              PWM0H = ~bezel_dim_byte;
1243   3              }
1244   2              else
1245   2              {
1246   3              PWM0L = dim_value[display_dim_byte];
1247   3              //brt_byte = dim_value[display_dim_byte];
1248   3              PWM0H = ~bezel_dim_byte;
1249   3              }
1250   2      //;************************************************    
1251   2              if(echo == 0x31)                                                                //; send bezel dim echo
1252   2              {
1253   3              SBUF = CONTROL_COMMAND;
1254   3              transmit_data();
1255   3              SBUF = BEZEL_DIM_ID;
1256   3              transmit_data();
1257   3              SBUF = s_bezel_dim_msn;
1258   3              transmit_data();
1259   3              SBUF = s_bezel_dim_lsn;
1260   3              transmit_data();
1261   3              SBUF = 0x0D;
1262   3              transmit_data();
C51 COMPILER V8.06   75_8902                                                               01/04/2022 08:22:26 PAGE 22  

1263   3              SBUF = 0x0A;
1264   3              transmit_data();
1265   3              }
1266   2      //;************************************************     
1267   2              update_bezel_dimming_bit = 0;
1268   2      //;************************************************ 
1269   2              }  
1270   1      }
1271          //;************************************************
1272          void send_status(void)
1273          {
1274   1      if(send_status_bit)
1275   1              {
1276   2      //;************************************************
1277   2              ACC     = PANEL_STATUS;
1278   2              SBUF = ACC;                                                     //1
1279   2              transmit_data();
1280   2      //;************************************************
1281   2              ACC = PB_41_Status;                                     //2 
1282   2              SBUF = ACC;     
1283   2              transmit_data();
1284   2      //;************************************************
1285   2              ACC = PB_42_Status;                                     //3
1286   2              SBUF = ACC;     
1287   2              transmit_data();
1288   2      //;************************************************
1289   2              ACC = PB_43_Status;                                     //4 
1290   2              SBUF = ACC;     
1291   2              transmit_data();
1292   2      //;************************************************
1293   2              ACC = PB_44_Status;                                     //5
1294   2              SBUF = ACC;     
1295   2              transmit_data();
1296   2      //;************************************************
1297   2              ACC = PB_45_Status;                                     //6
1298   2              SBUF = ACC;     
1299   2              transmit_data();
1300   2      //;************************************************
1301   2              ACC = PB_46_Status;                                     //7
1302   2              SBUF = ACC;     
1303   2              transmit_data();
1304   2      //;************************************************
1305   2              ACC = PB_47_Status;                                     //8 
1306   2              SBUF = ACC;     
1307   2              transmit_data();
1308   2      //;************************************************
1309   2              ACC = PB_48_Status;                                     //9
1310   2              SBUF = ACC;     
1311   2              transmit_data();
1312   2      //;************************************************
1313   2              ACC = PB_49_Status;                                     //10
1314   2              SBUF = ACC;     
1315   2              transmit_data();
1316   2      //;************************************************
1317   2              ACC = PB_4A_Status;                                     //11
1318   2              SBUF = ACC;     
1319   2              transmit_data();
1320   2      //;************************************************
1321   2              ACC = PB_4B_Status;                                     //12
1322   2              SBUF = ACC;     
1323   2              transmit_data();
1324   2      //;************************************************
C51 COMPILER V8.06   75_8902                                                               01/04/2022 08:22:26 PAGE 23  

1325   2              ACC = PB_4C_Status;                                     //13 
1326   2              SBUF = ACC;     
1327   2              transmit_data();
1328   2      //;************************************************
1329   2              ACC = PB_4D_Status;                                     //14    
1330   2              SBUF = ACC;     
1331   2              transmit_data();
1332   2      //;************************************************
1333   2              ACC = PB_4E_Status;                                     //15 
1334   2              SBUF = ACC;     
1335   2              transmit_data();
1336   2      //;************************************************
1337   2              ACC = PB_4F_Status;                                     //16 
1338   2              SBUF = ACC;     
1339   2              transmit_data();
1340   2      //;************************************************
1341   2              ACC = PB_50_Status;                                     //17
1342   2              SBUF = ACC;     
1343   2              transmit_data();
1344   2      //;************************************************
1345   2              ACC = PB_51_Status;                                     //18 
1346   2              SBUF = ACC;     
1347   2              transmit_data();
1348   2      //;************************************************
1349   2              ACC = BRT_PB_Status;                            //19 
1350   2              SBUF = ACC;     
1351   2              transmit_data();        
1352   2      //;************************************************
1353   2              ACC = ENC_PB_Status;                            //20 
1354   2              SBUF = ACC;     
1355   2              transmit_data();
1356   2      //;************************************************
1357   2              ACC = 0x00;                                                     //21
1358   2              SBUF = ACC;     
1359   2              transmit_data();
1360   2      //;************************************************
1361   2              ACC = 0x00;                                                     //22 
1362   2              SBUF = ACC;     
1363   2              transmit_data();
1364   2      //;************************************************
1365   2              ACC = brt_msn;                                          //23 
1366   2              SBUF = ACC;     
1367   2              transmit_data();
1368   2      //;************************************************
1369   2              ACC = brt_lsn;                                          //24
1370   2              SBUF = ACC;     
1371   2              transmit_data();
1372   2      //;************************************************
1373   2              ACC = enc_msn;                                          //25
1374   2              SBUF = ACC;     
1375   2              transmit_data();
1376   2      //;************************************************
1377   2              ACC = enc_lsn;                                          //26
1378   2              SBUF = ACC;     
1379   2              transmit_data();
1380   2      //;************************************************
1381   2              ACC = s_display_dim_msn;                        //27 
1382   2              SBUF = ACC;     
1383   2              transmit_data();
1384   2      //;************************************************
1385   2              ACC = s_display_dim_lsn;                        //28 
1386   2              SBUF = ACC;     
C51 COMPILER V8.06   75_8902                                                               01/04/2022 08:22:26 PAGE 24  

1387   2              transmit_data();
1388   2      //;************************************************
1389   2              ACC = s_contrast_msn;                           //29
1390   2              SBUF = ACC;     
1391   2              transmit_data();
1392   2      //;************************************************
1393   2              ACC = s_contrast_lsn;                           //30
1394   2              SBUF = ACC;     
1395   2              transmit_data();
1396   2      //;************************************************
1397   2              ACC = s_bezel_dim_msn;                          //31
1398   2              SBUF = ACC;     
1399   2              transmit_data();
1400   2      //;************************************************
1401   2              ACC = s_bezel_dim_lsn;                          //32
1402   2              SBUF = ACC;     
1403   2              transmit_data();
1404   2      //;************************************************
1405   2              ACC = s_skidball_msn;                           //33 
1406   2              SBUF = ACC;     
1407   2              transmit_data();
1408   2      //;************************************************
1409   2              ACC = s_skidball_lsn;                           //34
1410   2              SBUF = ACC;     
1411   2              transmit_data();
1412   2      //;************************************************
1413   2              ACC = 0x00;                                                     //35
1414   2              SBUF = ACC;     
1415   2              transmit_data();
1416   2      //;************************************************
1417   2              ACC = 0x00;                                                     //36
1418   2              SBUF = ACC;     
1419   2              transmit_data();
1420   2      //;************************************************
1421   2              ACC = 0x0D;                                                     //37 
1422   2              SBUF = ACC;     
1423   2              transmit_data();
1424   2      //;************************************************
1425   2              ACC = 0x0A;                                                     //38
1426   2              SBUF = ACC;     
1427   2              transmit_data();
1428   2      //;************************************************
1429   2              if(echo == 0x31)                                                                //; send panel status request echo
1430   2              {
1431   3              DELAY_LOOP_Wait(100);
1432   3              SBUF = PANEL_STATUS;
1433   3              transmit_data();
1434   3              SBUF = 0x0D;
1435   3              transmit_data();
1436   3              SBUF = 0x0A;
1437   3              transmit_data();
1438   3              }
1439   2              send_status_bit = 0;
1440   2      //;************************************************
1441   2              }
1442   1      }
1443          //;************************************************
1444          void send_single_sw_status(void)
1445          {
1446   1      if(send_single_switch_status)
1447   1              {
1448   2      //;************************************************
C51 COMPILER V8.06   75_8902                                                               01/04/2022 08:22:26 PAGE 25  

1449   2              if(switch_id == 0x41)
1450   2              {
1451   3              Switch_Data = PB_41_Status;
1452   3              switch_send();
1453   3              }       
1454   2              if(switch_id == 0x42)
1455   2              {
1456   3              Switch_Data = PB_42_Status;
1457   3              switch_send();
1458   3              }       
1459   2              if(switch_id == 0x43)
1460   2              {
1461   3              Switch_Data = PB_43_Status;
1462   3              switch_send();
1463   3              }
1464   2              if(switch_id == 0x44)
1465   2              {
1466   3              Switch_Data = PB_44_Status;
1467   3              switch_send();
1468   3              }
1469   2              if(switch_id == 0x45)
1470   2              {
1471   3              Switch_Data = PB_45_Status;
1472   3              switch_send();
1473   3              }
1474   2              if(switch_id == 0x46)
1475   2              {
1476   3              Switch_Data = PB_46_Status;
1477   3              switch_send();
1478   3              }
1479   2              if(switch_id == 0x47)
1480   2              {
1481   3              Switch_Data = PB_47_Status;
1482   3              switch_send();
1483   3              }
1484   2              if(switch_id == 0x48)
1485   2              {
1486   3              Switch_Data = PB_48_Status;
1487   3              switch_send();
1488   3              }
1489   2              if(switch_id == 0x49)
1490   2              {
1491   3              Switch_Data = PB_49_Status;
1492   3              switch_send();
1493   3              }
1494   2              if(switch_id == 0x4A)
1495   2              {
1496   3              Switch_Data = PB_4A_Status;
1497   3              switch_send();
1498   3              }
1499   2              if(switch_id == 0x4B)
1500   2              {
1501   3              Switch_Data = PB_4B_Status;
1502   3              switch_send();
1503   3              }
1504   2              if(switch_id == 0x4C)
1505   2              {
1506   3              Switch_Data = PB_4C_Status;
1507   3              switch_send();
1508   3              }
1509   2              if(switch_id == 0x4D)
1510   2              {
C51 COMPILER V8.06   75_8902                                                               01/04/2022 08:22:26 PAGE 26  

1511   3              Switch_Data = PB_4D_Status;
1512   3              switch_send();
1513   3              }
1514   2              if(switch_id == 0x4E)
1515   2              {
1516   3              Switch_Data = PB_4E_Status;
1517   3              switch_send();     
1518   3              }
1519   2              if(switch_id == 0x4F)
1520   2              {
1521   3              Switch_Data = PB_4F_Status;
1522   3              switch_send();
1523   3              }
1524   2              if(switch_id == 0x50)
1525   2              {
1526   3              Switch_Data = PB_50_Status;
1527   3              switch_send();
1528   3              }
1529   2              if(switch_id == 0x51)
1530   2              {
1531   3              Switch_Data = PB_51_Status;
1532   3              switch_send();
1533   3              }
1534   2              if(switch_id == 0x52)
1535   2              {
1536   3              Switch_Data = BRT_PB_Status;
1537   3              switch_send();
1538   3              }
1539   2              if(switch_id == 0x53)
1540   2              {
1541   3              Switch_Data = ENC_PB_Status;
1542   3              switch_send();
1543   3              }
1544   2      //;************************************************    
1545   2              if(echo == 0x31)                                                                //; send echo
1546   2              {
1547   3              DELAY_LOOP_Wait(100);
1548   3              SBUF = SWITCH_STATUS;
1549   3              transmit_data();
1550   3              SBUF = switch_id;
1551   3              transmit_data();
1552   3              SBUF = 0x0D;
1553   3              transmit_data();
1554   3              SBUF = 0x0A;
1555   3              transmit_data();
1556   3              }
1557   2              send_single_switch_status = 0;
1558   2      //;************************************************
1559   2              }
1560   1      }
1561          //;************************************************
1562          void switch_send(void)
1563          {
1564   1              SBUF = SWITCH_STATUS;
1565   1              transmit_data();
1566   1              SBUF = switch_id;
1567   1              transmit_data();
1568   1              SBUF = Switch_Data;
1569   1              transmit_data();
1570   1              SBUF = 0x0D;
1571   1              transmit_data();
1572   1              SBUF = 0x0A;
C51 COMPILER V8.06   75_8902                                                               01/04/2022 08:22:26 PAGE 27  

1573   1              transmit_data();        
1574   1      }
1575          //;************************************************
1576          void send_command_values(void)
1577          {
1578   1      if(send_display_dim_values)
1579   1              {
1580   2              SBUF = CONTROL_COMMAND;
1581   2              transmit_data();
1582   2      //;************************************************     
1583   2              SBUF = DISPLAY_DIM_ID;
1584   2              transmit_data();
1585   2      //;************************************************     
1586   2              SBUF = s_display_dim_msn;
1587   2              transmit_data();
1588   2      //;************************************************
1589   2              SBUF = s_display_dim_lsn;
1590   2              transmit_data();
1591   2      //;************************************************     
1592   2              SBUF = 0x0D;
1593   2              transmit_data();
1594   2      //;************************************************     
1595   2              SBUF = 0x0A;
1596   2              transmit_data();
1597   2      //;************************************************     
1598   2              send_display_dim_values = 0;
1599   2      //;************************************************
1600   2              if(echo == 0x31)                                                                //; send command dim echo
1601   2              {
1602   3              DELAY_LOOP_Wait(100);
1603   3              SBUF = CONTROL_COMMAND;
1604   3              transmit_data();
1605   3      //;************************************************     
1606   3              SBUF = DISPLAY_DIM_ID;
1607   3              transmit_data();
1608   3              SBUF = 0x0D;
1609   3              transmit_data();
1610   3      //;************************************************     
1611   3              SBUF = 0x0A;
1612   3              transmit_data();
1613   3              }       
1614   2              }
1615   1      //;************************************************
1616   1      if(send_contrast_values)
1617   1              {
1618   2              SBUF = CONTROL_COMMAND;
1619   2              transmit_data();
1620   2      //;************************************************     
1621   2              SBUF = CONTRAST_ID;
1622   2              transmit_data();
1623   2      //;************************************************     
1624   2              SBUF = s_contrast_msn;
1625   2              transmit_data();
1626   2      //;************************************************
1627   2              SBUF = s_contrast_lsn;
1628   2              transmit_data();
1629   2      //;************************************************     
1630   2              SBUF = 0x0D;
1631   2              transmit_data();
1632   2      //;************************************************     
1633   2              SBUF = 0x0A;
1634   2              transmit_data();
C51 COMPILER V8.06   75_8902                                                               01/04/2022 08:22:26 PAGE 28  

1635   2      //;************************************************     
1636   2              send_contrast_values = 0;
1637   2      //;************************************************
1638   2              if(echo == 0x31)                                                                //; send command dim echo
1639   2              {
1640   3              DELAY_LOOP_Wait(100);
1641   3              SBUF = CONTROL_COMMAND;
1642   3              transmit_data();
1643   3      //;************************************************     
1644   3              SBUF = CONTRAST_ID;
1645   3              transmit_data();
1646   3              SBUF = 0x0D;
1647   3              transmit_data();
1648   3      //;************************************************     
1649   3              SBUF = 0x0A;
1650   3              transmit_data();
1651   3              }       
1652   2              }
1653   1      //;************************************************
1654   1      if(send_bezel_dim_values)
1655   1              {
1656   2              SBUF = CONTROL_COMMAND;
1657   2              transmit_data();
1658   2      //;************************************************     
1659   2              SBUF = BEZEL_DIM_ID;
1660   2              transmit_data();
1661   2      //;************************************************     
1662   2              SBUF = s_bezel_dim_msn;
1663   2              transmit_data();
1664   2      //;************************************************
1665   2              SBUF = s_bezel_dim_lsn;
1666   2              transmit_data();
1667   2      //;************************************************     
1668   2              SBUF = 0x0D;
1669   2              transmit_data();
1670   2      //;************************************************     
1671   2              SBUF = 0x0A;
1672   2              transmit_data();
1673   2      //;************************************************
1674   2              send_bezel_dim_values = 0;
1675   2      //;************************************************     
1676   2              if(echo == 0x31)                                                                //; send command dim echo
1677   2              {
1678   3              DELAY_LOOP_Wait(100);
1679   3              SBUF = CONTROL_COMMAND;
1680   3              transmit_data();
1681   3      //;************************************************     
1682   3              SBUF = BEZEL_DIM_ID;
1683   3              transmit_data();
1684   3              SBUF = 0x0D;
1685   3              transmit_data();
1686   3      //;************************************************     
1687   3              SBUF = 0x0A;
1688   3              transmit_data();
1689   3              }
1690   2      //;************************************************     
1691   2              }
1692   1      //;************************************************
1693   1      if(send_skidball_values)
1694   1              {
1695   2              SBUF = CONTROL_COMMAND;
1696   2              transmit_data();
C51 COMPILER V8.06   75_8902                                                               01/04/2022 08:22:26 PAGE 29  

1697   2      //;************************************************     
1698   2              SBUF = SKIDBALL_ID;
1699   2              transmit_data();
1700   2      //;************************************************     
1701   2              SBUF = s_skidball_msn;
1702   2              transmit_data();
1703   2      //;************************************************
1704   2              SBUF = s_skidball_lsn;
1705   2              transmit_data();
1706   2      //;************************************************     
1707   2              SBUF = 0x0D;
1708   2              transmit_data();
1709   2      //;************************************************     
1710   2              SBUF = 0x0A;
1711   2              transmit_data();
1712   2      //;************************************************     
1713   2              send_skidball_values = 0;
1714   2      //;************************************************
1715   2              if(echo == 0x31)                                                                //; send command dim echo
1716   2              {
1717   3              DELAY_LOOP_Wait(100);
1718   3              SBUF = SKIDBALL_ID;
1719   3              transmit_data();
1720   3      //;************************************************     
1721   3              SBUF = BEZEL_DIM_ID;
1722   3              transmit_data();
1723   3              SBUF = 0x0D;
1724   3              transmit_data();
1725   3      //;************************************************     
1726   3              SBUF = 0x0A;
1727   3              transmit_data();
1728   3              }
1729   2              }
1730   1      //;************************************************
1731   1      }
1732          //;************************************************
1733          void send_option_values(void)
1734          {
1735   1      if(send_echo_value)
1736   1              {
1737   2              ACC = OPTIONS;
1738   2              SBUF = ACC;
1739   2              transmit_data();
1740   2      //;************************************************     
1741   2              ACC = ECHO_OPTION_ID;
1742   2              SBUF = ACC;
1743   2              transmit_data();
1744   2      //;************************************************     
1745   2              ACC = 0x30;
1746   2              SBUF = ACC;
1747   2              transmit_data();
1748   2      //;************************************************
1749   2              ACC = echo;
1750   2              SBUF = ACC;
1751   2              transmit_data();
1752   2      //;************************************************     
1753   2              ACC = 0x0D;
1754   2              SBUF = ACC;
1755   2              transmit_data();
1756   2      //;************************************************     
1757   2              ACC = 0x0A;
1758   2              SBUF = ACC;
C51 COMPILER V8.06   75_8902                                                               01/04/2022 08:22:26 PAGE 30  

1759   2              transmit_data();
1760   2      //;************************************************     
1761   2              send_echo_value = 0;
1762   2      //;************************************************
1763   2              if(echo == 0x31)                                                                //; send command dim echo
1764   2              {
1765   3              DELAY_LOOP_Wait(100);
1766   3              SBUF = OPTIONS;
1767   3              transmit_data();
1768   3      //;************************************************     
1769   3              SBUF = ECHO_OPTION_ID;
1770   3              transmit_data();
1771   3              SBUF = 0x0D;
1772   3              transmit_data();
1773   3      //;************************************************     
1774   3              SBUF = 0x0A;
1775   3              transmit_data();
1776   3              }       
1777   2              }
1778   1      //;************************************************
1779   1      if(send_realtime_value)
1780   1              {
1781   2              SBUF = OPTIONS;
1782   2              transmit_data();
1783   2      //;************************************************     
1784   2              SBUF = REALTIME_OPTION_ID;
1785   2              transmit_data();
1786   2      //;************************************************     
1787   2              SBUF = 0x30;
1788   2              transmit_data();
1789   2      //;************************************************
1790   2              SBUF = realtime;
1791   2              transmit_data();
1792   2      //;************************************************     
1793   2              SBUF = 0x0D;
1794   2              transmit_data();
1795   2      //;************************************************     
1796   2              SBUF = 0x0A;
1797   2              transmit_data();
1798   2      //;************************************************     
1799   2              send_realtime_value = 0;
1800   2      //;************************************************
1801   2              if(echo == 0x31)                                                                //; send command dim echo
1802   2              {
1803   3              DELAY_LOOP_Wait(100);
1804   3              SBUF = OPTIONS;
1805   3              transmit_data();
1806   3      //;************************************************     
1807   3              SBUF = REALTIME_OPTION_ID;
1808   3              transmit_data();
1809   3              SBUF = 0x0D;
1810   3              transmit_data();
1811   3      //;************************************************     
1812   3              SBUF = 0x0A;
1813   3              transmit_data();
1814   3              }
1815   2              }
1816   1      //;************************************************
1817   1      if(send_lcd_value)
1818   1              {
1819   2              SBUF = OPTIONS;
1820   2              transmit_data();
C51 COMPILER V8.06   75_8902                                                               01/04/2022 08:22:26 PAGE 31  

1821   2      //;************************************************     
1822   2              SBUF = BRT_CTRL_OPTION_ID;
1823   2              transmit_data();
1824   2      //;************************************************     
1825   2              SBUF = 0x30;
1826   2              transmit_data();
1827   2      //;************************************************
1828   2              SBUF = brt_control;
1829   2              transmit_data();
1830   2      //;************************************************     
1831   2              SBUF = 0x0D;
1832   2              transmit_data();
1833   2      //;************************************************     
1834   2              SBUF = 0x0A;
1835   2              transmit_data();
1836   2      //;************************************************     
1837   2              send_lcd_value = 0;
1838   2      //;************************************************
1839   2              if(echo == 0x31)                                                                //; send command dim echo
1840   2              {
1841   3              DELAY_LOOP_Wait(100);
1842   3              SBUF = OPTIONS;
1843   3              transmit_data();
1844   3      //;************************************************     
1845   3              SBUF = BRT_CTRL_OPTION_ID;
1846   3              transmit_data();
1847   3              SBUF = 0x0D;
1848   3              transmit_data();
1849   3      //;************************************************     
1850   3              SBUF = 0x0A;
1851   3              transmit_data();
1852   3              }
1853   2              }
1854   1      //;************************************************
1855   1      }
1856          //;************************************************
1857          void SER_INT(void) interrupt 4
1858          {
1859   1      unsigned char hold_byte,temp_byte,control_byte,option_byte;
1860   1      
1861   1      if(!TI)
1862   1      TI = 0;
1863   1      //;************************************************
1864   1              if (RI)
1865   1              {hold_byte = SBUF;                                              
1866   2               RI = 0;
1867   2      //;************************************************                                                                     
1868   2                      switch(hold_byte)                                               // 
1869   2                               {
1870   3      //;************************************************                                                                     
1871   3                              case SWITCH_STATUS:                                     //; 0x24
1872   3                                      receive_data(); 
1873   3                                      switch_id = SBUF;
1874   3                                      receive_data();                                 //; 0x0D
1875   3                                      receive_data();                                 //; 0x0A
1876   3                                      send_single_switch_status = 1;
1877   3                              break;
1878   3      //;************************************************
1879   3                              case PANEL_STATUS:                                      //; 0x26
1880   3                                      receive_data();                                 //; 0x0D
1881   3                                      receive_data();                                 //; 0x0A
1882   3                                      send_status_bit = 1;                    
C51 COMPILER V8.06   75_8902                                                               01/04/2022 08:22:26 PAGE 32  

1883   3                              break;
1884   3      //;************************************************
1885   3                              case CONTROL_COMMAND:                           //; 0x23                                 
1886   3                                       
1887   3                                      receive_data();
1888   3                                      temp_byte = SBUF;
1889   3      //;************************************************
1890   3      //;DISPLAY DIMMING
1891   3      //;************************************************                     
1892   3                              if(temp_byte == DISPLAY_DIM_ID)
1893   3                                      {                       
1894   4                                      receive_data();
1895   4                                      control_byte = SBUF;
1896   4                                      if(control_byte == 0x0D)
1897   4                                      {
1898   5                                      receive_data();                                 //; 0x0A
1899   5                                      send_display_dim_values = 1;                            
1900   5                                      break;
1901   5                                      }
1902   4                                      else
1903   4                                      {
1904   5                                      display_dim_msn = SBUF;
1905   5                                      receive_data();
1906   5                                      display_dim_lsn = SBUF;
1907   5                                      update_display_dimming_bit = 1;
1908   5                                      }
1909   4                                      }
1910   3      //;************************************************
1911   3      //;DISPLAY CONTRAST     
1912   3      //;************************************************             
1913   3                              if(temp_byte == CONTRAST_ID)
1914   3                                      {                       
1915   4                                      receive_data();
1916   4                                      control_byte = SBUF;
1917   4                                      if(control_byte == 0x0D)
1918   4                                      {                               
1919   5                                      receive_data();                                 //; 0x0A
1920   5                                      send_contrast_values = 1;
1921   5                                      break;
1922   5                                      }
1923   4                                      else
1924   4                                      {
1925   5                                      contrast_msn = SBUF;
1926   5                                      receive_data();
1927   5                                      contrast_lsn = SBUF;
1928   5                                      update_display_contrast_bit = 1;
1929   5                                      }
1930   4                                      }
1931   3      //;************************************************                     
1932   3      //:BEZEL DIMMING
1933   3      //;************************************************                     
1934   3                              if(temp_byte == BEZEL_DIM_ID)
1935   3                                      {
1936   4                                      receive_data();
1937   4                                      control_byte = SBUF;
1938   4                                      if(control_byte == 0x0D)
1939   4                                      {
1940   5                                      receive_data();                                 //; 0x0A
1941   5                                      send_bezel_dim_values = 1;
1942   5                                      break;
1943   5                                      }
1944   4                                      else
C51 COMPILER V8.06   75_8902                                                               01/04/2022 08:22:26 PAGE 33  

1945   4                                      {
1946   5                                      bezel_dim_msn = SBUF;                           
1947   5                                      receive_data();
1948   5                                      bezel_dim_lsn = SBUF;
1949   5                                      update_bezel_dimming_bit = 1;
1950   5                                      }
1951   4                                      }
1952   3      //;************************************************                                                             
1953   3      //;SKIDBALL CONTROL
1954   3      //;************************************************
1955   3                              if(temp_byte == SKIDBALL_ID)
1956   3                                      {
1957   4                                      receive_data();
1958   4                                      control_byte = SBUF;
1959   4                                      if(control_byte == 0x0D)
1960   4                                      {
1961   5                                      receive_data();                                 //; 0x0A
1962   5                                      send_skidball_values = 1;
1963   5                                      break;
1964   5                                      }
1965   4                                      else
1966   4                                      {
1967   5                                      skidball_msn = SBUF;                            
1968   5                                      receive_data();
1969   5                                      skidball_lsn = SBUF;
1970   5                                      update_skidball_bit = 1;
1971   5                                      }
1972   4                                      }
1973   3                                      receive_data();                                 //; 0x0D
1974   3                                      receive_data();                                 //; 0x0A
1975   3                              break;                                                  
1976   3      //;************************************************
1977   3                              case OPTIONS:                                           //; 0x25
1978   3                                      receive_data();
1979   3                                      temp_byte = SBUF;
1980   3      //;************************************************
1981   3      //;ECHO OPTION
1982   3      //;************************************************                     
1983   3                              if(temp_byte == ECHO_OPTION_ID)
1984   3                                      {
1985   4                                      receive_data();
1986   4                                      option_byte = SBUF;
1987   4                                      if(option_byte == 0x0D)
1988   4                                      {
1989   5                                      receive_data();                                 //; 0x0A
1990   5                                      send_echo_value = 1;
1991   5                                      break;
1992   5                                      }
1993   4                                      else
1994   4                                      {                                                                                               
1995   5                                      receive_data();
1996   5                                      echo = SBUF;
1997   5                                      }
1998   4                                      }
1999   3      //;************************************************
2000   3      //;SEND ON CHANGE OPTION
2001   3      //;************************************************                     
2002   3                              if(temp_byte == REALTIME_OPTION_ID)
2003   3                                      {
2004   4                                      receive_data();
2005   4                                      option_byte = SBUF;
2006   4                                      if(option_byte == 0x0D)
C51 COMPILER V8.06   75_8902                                                               01/04/2022 08:22:26 PAGE 34  

2007   4                                      {
2008   5                                      receive_data();                                 //; 0x0A
2009   5                                      send_realtime_value = 1;
2010   5                                      break;
2011   5                                      }
2012   4                                      else
2013   4                                      {
2014   5                                      receive_data();
2015   5                                      realtime = SBUF;
2016   5                                      }
2017   4                                      }
2018   3      //;************************************************                     
2019   3      //:LCD BRIGHTNESS CONTROL OPTION
2020   3      //;************************************************                     
2021   3                              if(temp_byte == BRT_CTRL_OPTION_ID)
2022   3                                      {
2023   4                                      receive_data();
2024   4                                      option_byte = SBUF;
2025   4                                      if(option_byte == 0x0D)
2026   4                                      {
2027   5                                      receive_data();                                 //; 0x0A
2028   5                                      send_lcd_value = 1;
2029   5                                      break;
2030   5                                      }
2031   4                                      else
2032   4                                      {
2033   5                                      receive_data();
2034   5                                      brt_control = SBUF;
2035   5                                      }
2036   4                                      }                               
2037   3                                      receive_data();                                 //; 0x0D
2038   3                                      receive_data();                                 //; 0x0A
2039   3                              break;
2040   3      //;************************************************
2041   3                              case ENC_POT_STATUS:                            //; 0x28        
2042   3      
2043   3                                      receive_data();
2044   3                                      temp_byte = SBUF;
2045   3      //;BRT POT STATUS                       
2046   3                              if(temp_byte == POT_ID)
2047   3                                      {
2048   4                                      send_pot_status = 1;
2049   4                                      } 
2050   3      //;ENC STATUS                   
2051   3                              if(temp_byte == ENC_ID)
2052   3                                      {
2053   4                                      send_encoder_status = 1;
2054   4                                      }                                                               
2055   3                                      receive_data();                                 //; 0x0D                                
2056   3                                      receive_data();                                 //;     0x0A
2057   3                              break;
2058   3      //;************************************************                                     
2059   3                              }                                                                       //; end case
2060   2      //;************************************************             
2061   2              }                                                                                       //end if RI
2062   1      }
2063          //;************************************************
2064          //void send_programs(void)
2065          //{
2066          //unsigned char i;
2067          //if(send_programs_bit)                                 // check to see if send program flag is set
2068          //      {
C51 COMPILER V8.06   75_8902                                                               01/04/2022 08:22:26 PAGE 35  

2069          //              SBUF = FIRMWARE_COMMAND;        
2070          //              transmit_data();
2071          //;micro program***********************************                     
2072          //      for(i = 0; i < 4; i++)
2073          //              {       
2074          //              SBUF = RS_micro_firmware[i];    
2075          //              transmit_data();                                    
2076          //              }
2077          //;fpga program************************************                     
2078          //      for(i = 0; i < 4; i++)
2079          //              {                       
2080          //              SBUF = RS_fpga_firmware[i];
2081          //              transmit_data();        
2082          //              }
2083          //;************************************************                             
2084          //      send_programs_bit = 0;                          // clear the flag
2085          //      }
2086          //
2087          //;************************************************


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   3579    ----
   CONSTANT SIZE    =    784    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     87       1
   IDATA SIZE       =   ----    ----
   BIT SIZE         =     16    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
